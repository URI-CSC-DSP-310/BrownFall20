---
jupytext:
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.12
    jupytext_version: 1.6.0
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---

# Class 12: Constructing Datasets from Multiple Sources

```{code-cell} ipython3
import pandas as pd
```
## Introduction
Sometimes we use data from multiple soources. For example data may be provided across a bunch of tables and we want to put them together. Or we may want to build our own dataset to answer the questions that we want to ask.
For example we have a dataset of people who have been pulled over by the police car, and need to compare distribution of them between day and night times. If we we only have time of being pulled over without mentioning day/night, we can use another dataset including time of sunset for every day and build our own dataset out of these two dataset to find the answer.
Later we will alsor learn about getting data out of databses with some small database operations through SQLite and some python libararies.


To use relative paths as in class (`data/2018-games.csv`) instead of a full url `https://raw.githubusercontent.com/rhodyprog4ds/inclass-data/main/2018-games.csv`, download data from [this GitHub repo](https://github.com/rhodyprog4ds/inclass-data) by clicking on the green code button and choosing .zip. Then unzip the data and save it in a data folder in the same folder as the notebook. For the class notes, the urls make it so that the notebook can run without having to store the data in another place. 


```{code-cell} ipython3
games_df18 = pd.read_csv('https://raw.githubusercontent.com/rhodyprog4ds/inclass-data/main/2018-games.csv')
games_df19 = pd.read_csv('https://raw.githubusercontent.com/rhodyprog4ds/inclass-data/main/2019-games.csv')
```

<!-- annotate: Stacking DataFrames -->
## Stacking DataFrames
Lets look at the first couple of rows to see how the configuration of data is.

```{code-cell} ipython3
games_df18.head(2)
```

```{code-cell} ipython3
games_df19.head(2)
```
As we can see, both datasets have the same columns, and just for two different years.
```{code-cell} ipython3
games_df18.shape
```

```{code-cell} ipython3
games_df19.shape
```
Lets concate two dataframes to make one dataframe out of them.
```{code-cell} ipython3
games_df = pd.concat([games_df18,games_df19])
games_df.shape
```
As we can see rows are added up but we have the same numbe of rcolums.

```{code-cell} ipython3
games_df.columns
```
Lets drop the column we do not need/
```{code-cell} ipython3
games_df.drop(columns= 'Unnamed: 0',inplace=True,)
games_df.head(2)
```

<!-- annotate: Merging Data Frames -->
## Merging Data Frames
Now we read another dataset which some of its columns are the same as dataframe "games_df" and some are different. 
```{code-cell} ipython3
teams_df = pd.read_csv('https://raw.githubusercontent.com/rhodyprog4ds/inclass-data/main/teams.csv')
teams_df.head(2)
```
We use left_on='TEAM_ID' and right_on = 'HOME_TEAM_ID' to match two dataframes.
```{code-cell} ipython3
merge1_df = pd.merge(teams_df,games_df,left_on='TEAM_ID', right_on = 'HOME_TEAM_ID')
merge1_df.head(2)
```
We want information for each game and append the team info onto that. So, lets try another settings in our mergging. 

```{code-cell} ipython3
merge1_df.shape
```

```{code-cell} ipython3
merge2_df = pd.merge(teams_df, games_df,left_on='TEAM_ID', right_on = 'HOME_TEAM_ID', how='outer')
```

```{code-cell} ipython3
merge2_df.head(2)
```

```{code-cell} ipython3
merge2_df.shape
```
We can group by "ARENA" and then look at the "mean" statistics.
```{code-cell} ipython3
merge1_df.groupby('ARENA').mean()
```

<!-- annotate: How to combine the same data for different outcomes -->
## How to combine the same data for different outcomes
We can combine datasets which have different shapes. 
Lets now read info about the players.
```{code-cell} ipython3
players18 = pd.read_csv('https://raw.githubusercontent.com/rhodyprog4ds/inclass-data/main/2018-players.csv')
players19 = pd.read_csv('https://raw.githubusercontent.com/rhodyprog4ds/inclass-data/main/2019-players.csv')
players18.head()
```

```{code-cell} ipython3
players18.shape, players19.shape
```
Lets stack on each other info of players from 2018 and 2019 players datasets.
```{code-cell} ipython3
pd.concat([players18,players19]).shape
```

```{code-cell} ipython3
pd.merge(players18,players19,)
```
If we merge with on='PLAYER_ID', we get the info of players who played both seasons.
```{code-cell} ipython3
pd.merge(players18,players19,on='PLAYER_ID', how='inner')
```

```{code-cell} ipython3
pd.merge(players18,players19,on='PLAYER_ID', how='outer')
```

```{code-cell} ipython3
pd.merge(players18,players19,on='PLAYER_ID', how='left')
```

```{code-cell} ipython3

```
## Try it yourself

Try different merges and inspect them:
- how many rows & columns?
- Where are NaN values inserted?
- What rows from the original datasets are not included?
- describe each type of merge in your own words


Split a DataFrame into separate data frames by subsetting the columns and indexing the rows with `loc`, then use concat to put it back together. Programmatically check that it's back together correctly.
